- Test setup for Henzell queries:
  - Small logfile snapshot.
  - Load into test db
  - Run queries and check for expected results.

!lg * cow bar=moo cow foo zap=tao

Allow quo

Extended Henzell queries (joins, yay):
- Fork query as a separate process, keep track of PID.
- When child exits, display its output (presumably dumped to a file)
- Set alarm to kill child after 30s
- Allow !cancelquery to cancel any running query immediately

Join steps:
1. Identify subqueries
2. Identify join parameters. Subquery must have x=<field> to specify joins,
   OR must have s=<field> to specify grouping, in which case the same <field>
   is assumed as the join condition.
3. Create query with joins. Easy!

Conditions:
1. Robust parser.
2. Must handle top-level ratio queries.
3. Must handle milestone + logfile joins as subqueries.

Parser special cases:
 - Games by players who have more than X wins:

   SELECT * FROM logrecord WHERE pname IN (
      SELECT pname FROM logrecord WHERE ktyp='winning' GROUP BY pname
      HAVING COUNT(*) > 3 );

   !lg * [[ * win s=name :: count > 3 ]]
     ^^ x=field is implied if no x=<foo> is specified and there's an s=field

- Games that are first wins:
explain extended
   SELECT charabbrev, count(*) AS c FROM logrecord a,
     (SELECT pname, MIN(tstart) AS tstart FROM logrecord
      WHERE ktyp = 'winning' GROUP BY pname) b
   WHERE a.pname = b.pname AND a.tstart = b.tstart
   group by charabbrev
   order by c DESC;

   !lg * [[ * win s=name x=name,min(start) ]] s=char

   Use: x= in subqueries to select join fields.

- Player who has the most combo highscores:

   Combo highscores: char, MAX(score) FROM logrecord GROUP BY char

   Players with combo highscores:
   SELECT name, COUNT(*) c FROM logrecord WHERE char = ch.char AND sc = ch.sc
   GROUP BY name ORDER BY c DESC

   !lg * [[ * s=char x=char,max(sc) ]] s=name

- Game with most Boris kills:
   !lg * [[ !lm * uniq=Boris s=game_id ]]
   (The implicit order by COUNT(*) is used here).

- Games with most milestones in Shoals:
   !lg * [[!lm * Shoals s=game_id]]

- Lairless wins:
   !lg * win [[!lm * br.enter=Lair match=start,name x=count]]=0

   OR

   !lg * win [[!lm * br.enter=Lair start=q:start name=q:name x=count]]=0

   Prefixes:
   where qp: implies the parent query, q: the top-level query. Other queries
   may use aliases specified in the subquery.


Different kinds of subqueries:
- General JOIN query -- just use x=fields to join
- Correlated subquery: use match=field1,field2 to correlate on those field
  values.
- Correlated subquery as expression: use subquery OP value to match.
- EXISTS subquery: exists[[ ]] (may also be correlated)
- NOT EXISTS subquery: !exists[[ ]] (may also be correlated)

 Real query parser.

---------------------------------------------------

- Save query:
  !alias blarg !lg <xyz>
  !blarg <stuff> => !lg <xyz> +++ <stuff>
  !blarg is checked only if none of the existing commands match.
         Would be nice if !alias <keywords> could work.

  +++ operator to combine multiple arglists.

---------------------------------------------------  
  
!won * t pa <- fix
!won * sprint ?

---------------------------------------------------
Allow multiple s= conditions:

s=char,god => group by char + god: 10x DEFE (3x Okawaru, 2x Xom, ...), 5x MuPr

Allow !ttyrec to use ruby dir lister.

---------------------------------------------------

!lg general syntax:

[(mode-select)] (query-form) [s=grouping] [x=show-fields] [o=ordering]
[ / (query-form) [?: extended filters]]

where query-form = <nick-selector> [keywords...] [key-op-val arguments]