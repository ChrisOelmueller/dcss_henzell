- Nested grouping: s=char,xl
  15x DEFE (2x 10, 3x 5)

- When using x=FOO in a group-by query, automatically order by FOO desc.
- Allow x=-FOO as well.


- Test setup for Henzell queries:
  - MySQL dump from Sequell - old games (keep only 2009 and newer games)
  - Load into test db
  - Build list of queries
  - Use a script that runs queries against the various commands being tested
    and creates a test suite of commands and expected outputs.
  - Run queries and check for expected results.

- New computed fields:
  - Nth win for player.
  - Nth streak win for player.
  - Streak breaker flag.

- Query construction:
  - Top-level query may be:
    - Standard game query, in which case select all game fields
      (effectively SELECT *)
            Eg: !lg * DEFE killer=hobgoblin
    - s=foo,bar,baz, in which case use GROUP BY on the nominated fields and
      SELECT foo, bar, baz, COUNT(*) AS c
            Eg: !lg * DEFE s=ckiller,sk
    - Non-summary query using x=aggregate(foo),...:
      SELECT aggregate(foo)
            Eg: !lg * Ke x=avg(hp), max(hp), min(hp)

    Any of these queries for !lm may be joined to the listgame table,
    in which case the join is by name + rstart, and all selected fields
    are explicitly aliased to the relevant table: unqualified fields will
    reference milestones table if present, or listgame table if not.
    Qualified fields will reference the qualified table.

  - Subquery may be:
    - Simple JOIN subquery. The subquery is run and then joined on based
      on the provided fields.
         !lg * [[ !lm * uniq=Boris s=game_id ]]
      finds the game with the most Boris kills.

      If no x=field is provided, join happens on the grouped field
      selected by s=field

    - Expression subquery:
      A subquery may be used as an expression:
         !lg * $[[!lm * match=name,rstart]]=0
      (Shows games with no milestones; expensive)

      An expression subquery may use a single x=foo to select an
      expression; if no x=foo is specified, x=count is assumed.

    - exists/not exists subquery:
         !lg * win !$e[[!lm * Lair match=name,rstart]]
      (finds Lairless wins)

- New grammar -- error checking needed:
  Many errors cannot be caught by the parser. These include:
  - Too many summarize clauses
  - Too many order clauses
  - Too many result indexes
  - Ratio queries in subqueries.
  - Type mismatches in expressions.

  The query compiler must check explicitly for these conditions after
  parsing.

- Allow query expressions:
  -int!=${dex} (expressions enclosed in ${})
  ${expr1}!=${expr2}
  ${int+dex}<${str}

  ${int + $[[ * x=count ]]}

  expressions may be:
   - simple field names
   - full SQL arithmetic, boolean expressions: x+b*c, etc using nested
     expressions.
   - subqueries.

Extended Henzell queries (joins, yay):
- Fork query as a separate process, keep track of PID.
- When child exits, display its output (presumably dumped to a file)
- Set alarm to kill child after 30s. If the alarm fires, get MySQL's
  process list, find any currently executing query and nuke it with
  KILL CONNECTION.
- Allow !cancelquery to cancel any running query immediately using
  the same process kill + connection kill.

Join steps:
1. Identify subqueries
2. Identify join parameters. Subquery must have x=<field> to specify joins,
   OR must have s=<field> to specify grouping, in which case the same <field>
   is assumed as the join condition.
3. Create query with joins. Easy!

Conditions:
1. Robust parser.
2. Must handle top-level ratio queries.
3. Must handle milestone + logfile joins as subqueries.

Parser special cases:
 - Games by players who have more than X wins:

   SELECT * FROM logrecord WHERE pname IN (
      SELECT pname FROM logrecord WHERE ktyp='winning' GROUP BY pname
      HAVING COUNT(*) > 3 );

   !lg * [[ * win s=name ?: count > 3 ]]
     ^^ x=field is implied if no x=<foo> is specified and there's an s=field

- Games that are first wins:
explain extended
   SELECT charabbrev, count(*) AS c FROM logrecord a,
     (SELECT pname, MIN(tstart) AS tstart FROM logrecord
      WHERE ktyp = 'winning' GROUP BY pname) b
   WHERE a.pname = b.pname AND a.tstart = b.tstart
   group by charabbrev
   order by c DESC;

   !lg * [[ * win s=name x=name,min(start) ]] s=char

   Use: x= in subqueries to select join fields.

- Player who has the most combo highscores:

   Combo highscores: char, MAX(score) FROM logrecord GROUP BY char

   Players with combo highscores:
   SELECT l.pname, COUNT(*) c FROM logrecord l,
    (SELECT charabbrev, MAX(sc) sc FROM logrecord GROUP BY charabbrev) ch
   WHERE l.charabbrev = ch.charabbrev AND l.sc = ch.sc
   GROUP BY l.pname ORDER BY c DESC

   !lg * [[ * s=char x=char,max(sc) ]] s=name

- Game with most Boris kills:
   !lg * [[ !lm * uniq=Boris s=game_id ]]
   (The implicit order by COUNT(*) is used here).

- Games with most milestones in Shoals:
   !lg * [[!lm * Shoals s=game_id]]

- Lairless wins:
   !lg * win $[[!lm * br.enter=Lair match=start,name x=count]]=0

   OR

   !lg * win $[[!lm * br.enter=Lair start=q:start name=q:name x=count]]=0

   Prefixes:
   where qp: implies the parent query, q: the top-level query. Other queries
   may use aliases specified in the subquery.


Different kinds of subqueries:
- General JOIN query -- just use x=fields to join
- Correlated subquery: use match=field1,field2 to correlate on those field
  values.
- Correlated subquery as expression: $[[ ]] <op> <val>
- EXISTS subquery: exists[[ ]] (may also be correlated)
- NOT EXISTS subquery: !exists[[ ]] (may also be correlated)

 Real query parser.

---------------------------------------------------

- Save query:
  !alias blarg !lg <xyz>
  !blarg <stuff> => !lg <xyz> +++ <stuff>
  !blarg is checked only if none of the existing commands match.
         Would be nice if !alias <keywords> could work.

  +++ operator to combine multiple arglists.

---------------------------------------------------  
  
!won * t pa <- fix
!won * sprint ?

---------------------------------------------------
Allow multiple s= conditions:

s=char,god => group by char + god: 10x DEFE (3x Okawaru, 2x Xom, ...), 5x MuPr

Allow !ttyrec to use ruby dir lister.

---------------------------------------------------

!lg general syntax:

[(mode-select)] (query-form) [s=grouping] [x=show-fields] [o=ordering]
[ / (query-form) [?: extended filters]]

where query-form = <nick-selector> [keywords...] [key-op-val arguments]